# Uncontrolled Search Path Element (CWE-427) in Java

#### Understanding Uncontrolled Search Path Element

### Definition and Variations

**Uncontrolled Search Path Element** (also known as CWE-427) is a vulnerability that occurs when a software component utilizes a path to an executable without properly validating or controlling it. This can allow attackers to control which executable is run, possibly leading to the execution of unintended, malicious code.

In the context of Java applications, specifically web applications developed using popular frameworks like Spring, Struts, or JSF, this vulnerability typically manifests when dealing with:
1. **Library and Dependency Management**: Referring to paths in configurations that load libraries or dependencies.
2. **Class Loading**: Dynamically loading classes from user-specified paths.
3. **Executables or Command Execution**: Running external commands or executables using unvalidated or improperly controlled paths.
4. **Resource Loading**: Including resources, templates, or configurations based on dynamic inputs.

Each of these scenarios can lead to severe consequences if an attacker can manipulate the paths to point to malicious files.


### Detecting Uncontrolled Search Path Element in Java Web Applications

Detecting these vulnerabilities with OWASP ZAP's Zest scripting involves crafting scripts to identify unvalidated or improperly controlled paths. The goal is to create detection rules that minimize false negatives and positives.

#### 1. **Library and Dependency Management**

In frameworks like Maven, Gradle, or within the application itself, an attacker could potentially specify dependencies from unsecured locations.

**Zest Script Sample**:
```json
{
  "about": "Detecting Uncontrolled Search Path Element in Dependency Management",
  "zestVersion": "0.8",
  "title": "Detect Dependency Path Vulnerability",
  "prefix": "http://{your-web-app}",
  "statements": [
    {
      "elementType": "ZestRequest",
      "url": "http://{your-web-app}/path-to-parameter-vulerability",
      "method": "GET",
      "index": 1
    },
    {
      "elementType": "ZestConditionRegex",
      "regex": "(.*jsp|.*properties|.*xml|.*yml)",
      "location": "BODY",
      "ifStatements": [
        {
          "elementType": "ZestActionFail",
          "message": "Potential Uncontrolled Search Path Element vulnerability detected."
        }
      ],
      "elseStatements": [],
      "index": 2
    }
  ]
}
```

#### 2. **Class Loading**

Custom class loaders that accept class paths from users can be exploited.

**Zest Script Sample**:
```json
{
  "about": "Detecting Uncontrolled Search Path Element in Class Loading",
  "zestVersion": "0.8",
  "title": "Detect Class Loading Path Vulnerability",
  "prefix": "http://{your-web-app}",
  "statements": [
    {
      "elementType": "ZestRequest",
      "url": "http://{your-web-app}/path-to-class-loader",
      "method": "GET",
      "index": 1
    },
    {
      "elementType": "ZestConditionRegex",
      "regex": "java/lang/ClassLoader",
      "location": "BODY",
      "ifStatements": [
        {
          "elementType": "ZestActionFail",
          "message": "Potential Uncontrolled Class Loading Path vulnerability detected."
        }
      ],
      "elseStatements": [],
      "index": 2
    }
  ]
}
```

#### 3. **Executables or Command Execution**

When applications execute system commands based on user inputs, paths need stringent validation.

**Zest Script Sample**:
```json
{
  "about": "Detecting Uncontrolled Search Path Element in Executing Commands",
  "zestVersion": "0.8",
  "title": "Detect Command Execution Path Vulnerability",
  "prefix": "http://{your-web-app}",
  "statements": [
    {
      "elementType": "ZestRequest",
      "url": "http://{your-web-app}/execute-command?path=../../bin/bash",
      "method": "GET",
      "index": 1
    },
    {
      "elementType": "ZestConditionRegex",
      "regex": "(/bin/bash|cmd.exe)",
      "location": "BODY",
      "ifStatements": [
        {
          "elementType": "ZestActionFail",
          "message": "Potential Uncontrolled Command Execution Path vulnerability detected."
        }
      ],
      "elseStatements": [],
      "index": 2
    }
  ]
}
```

#### 4. **Resource Loading**

Dynamic resource inclusion based on user input without proper validation.

**Zest Script Sample**:
```json
{
  "about": "Detecting Uncontrolled Search Path Element in Resource Loading",
  "zestVersion": "0.8",
  "title": "Detect Resource Loading Path Vulnerability",
  "prefix": "http://{your-web-app}",
  "statements": [
    {
      "elementType": "ZestRequest",
      "url": "http://{your-web-app}/load-resource?file=../../etc/passwd",
      "method": "GET",
      "index": 1
    },
    {
      "elementType": "ZestConditionRegex",
      "regex": "etc/passwd|ROOT.xml|web.xml",
      "location": "BODY",
      "ifStatements": [
        {
          "elementType": "ZestActionFail",
          "message": "Potential Uncontrolled Resource Loading Path vulnerability detected."
        }
      ],
      "elseStatements": [],
      "index": 2
    }
  ]
}
```

### Conclusion

By carefully crafting Zest scripts, we can detect various manifestations of Uncontrolled Search Path Element vulnerabilities in Java-based web applications. Each script targets specific points of user input that can affect path resolution in various frameworks, ensuring comprehensive detection with minimal false positives and negatives.

Reference:
- Various sections from the uploaded WSTG.md files discuss techniques for identifying path-related vulnerabilities and other insecure practices that can contribute to uncontrolled search path elements vulnerabilities      . 
- Zest scripting documentation provides details on how conditionals, actions, and requests are structured and utilized in detecting vulnerabilities with OWASP ZAP  .