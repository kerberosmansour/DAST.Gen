# Improper Neutralization of Special Elements used in a Command ('Command Injection') (CWE-077) in Java

#### Improper Neutralization of Special Elements used in a Command ('Command Injection')

Improper Neutralization of Special Elements used in a Command, commonly referred to as 'Command Injection', is a security issue where an attacker can inject arbitrary commands into a program, which gets executed by the server. This happens when user inputs are improperly validated and sanitized before being passed to the system's shell or other command execution mechanisms.

### What is Command Injection?

Command injection allows an attacker to run arbitrary commands on the host operating system via a vulnerable application. It can expose sensitive data or compromise the entire system. Attackers typically exploit web applications by manipulating input fields such as form submissions or URL parameters to include special characters and commands that are then executed.

To prevent command injection, input validation and proper sanitization are necessary. Disallowing or escaping special characters and ensuring only expected inputs are processed can mitigate these risks.

### Variations of Command Injection in Java Web Applications

In Java web applications, command injection can occur through various frameworks like Spring, Play, or even custom-built frameworks. The common entry points include:

1. **Runtime.exec() Usage**: When user inputs are concatenated directly into command strings passed to `Runtime.exec()` or `ProcessBuilder`.
2. **SQL Injection Leading to Shell Commands**: When SQL injection results cascade into command injection by leveraging stored procedures or database management commands.
3. **Script Execution**: Usage of scripting engines like Groovy or JavaScript within the application that executes commands based on user inputs.

### OWASP ZAP Zest Scripts for Detection

Here are sample Zest scripts to detect different command injection scenarios:

### 1. **Simple Command Injection**

**Case Description**: Direct use of `Runtime.exec()` in a servlet with tainted input.

**Zest Script**:
```json
{
  "title": "Detect Command Injection",
  "description": "Test for command injection vulnerabilities in user inputs",
  "steps": [
    {
      "type": "ZestRequest",
      "url": "http://example.com/vulnerableServlet?cmd=ls",
      "method": "GET",
      "headers": {},
      "data": ""
    },
    {
      "type": "ZestResponseLengthAssertion",
      "operator": ">"
      "value": 0
    },
    {
      "type": "ZestConditionRegex",
      "regex": "dir|ls|whoami",
      "location": "BODY",
      "ifStatements": [
        {
          "type": "ZestActionFail",
          "message": "Potential command injection detected on 'cmd' parameter"
        }
      ]
    }
  ]
}
```
### 2. **Command Injection via SQL Injection**

**Case Description**: SQL Injection that escalates to command execution.

**Zest Script**:
```json
{
  "title": "Detect SQL-Command Injection",
  "description": "Check for SQL injections that lead to command executions",
  "steps": [
    {
      "type": "ZestRequest",
      "url": "http://example.com/vulnerableEndpoint",
      "method": "POST",
      "headers": {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      "data": "username=admin&password=';DROP TABLE users;--"
    },
    {
      "type": "ZestConditionRegex",
      "regex": "Database error|syntax error|command not found",
      "location": "BODY",
      "ifStatements": [
        {
          "type": "ZestActionFail",
          "message": "Potential SQL command injection detected"
        }
      ]
    }
  ]
}
```

### 3. **Command Injection via Script Execution**

**Case Description**: Usage of scripting language execution based on user input, e.g., Groovy.

**Zest Script**:
```json
{
  "title": "Detect Script Execution Command Injection",
  "description": "Test for command injections through script executions",
  "steps": [
    {
      "type": "ZestRequest",
      "url": "http://example.com/runScript",
      "method": "POST",
      "headers": {
        "Content-Type": "application/json"
      },
      "data": "{\"script\":\"println('whoami')\"}"
    },
    {
      "type": "ZestConditionRegex",
      "regex": "root|user|admin",
      "location": "BODY",
      "ifStatements": [
        {
          "type": "ZestActionFail",
          "message": "Potential script execution command injection detected"
        }
      ]
    }
  ]
}
```

### Conclusion

Creating detection rules for command injection requires a comprehensive understanding of how different inputs can be manipulated in various frameworks and execution contexts. The Zest scripts provided can be a starting point for developing rules that aim to minimize false positives and negatives by focusing on common injection patterns and responses.

### References

- [WSTG.md - Testing for Command Injection]( )
- [WSTG.md - Special Characters for Command Injection]( )
- [Zest Scripting Documentation - OWASP ZAP]( )