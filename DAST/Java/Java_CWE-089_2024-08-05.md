# Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') (CWE-089) in Java

###### Explanation of SQL Injection

**SQL Injection** is a code injection technique that exploits vulnerabilities in an application's software by manipulating SQL queries. It occurs when user input is concatenated with SQL statements without proper neutralization, allowing attackers to interfere with the application's queries to the database.

**Overview:**
1. **Definition**: SQL injection happens when an attacker can influence the SQL queries that an application sends to its database. By inserting or "injecting" custom SQL statements, attackers can read or modify data or execute administrative operations on the database.
2. **Impact**: A successful SQL injection could lead to unauthorized data access, data manipulation, Interruption of database services, and even total control over the database server.

### Variations of SQL Injection in Java Web Applications

In Java-based web applications, especially those using popular frameworks like Spring, Hibernate, or JDBC, there are several scenarios where SQL injection can manifest. Below are descriptions of each scenario along with ZAP Zest scripts for detection.

1. **Classic SQL Injection via String Concatenation**
   - **Scenario**: Direct concatenation of user input into SQL queries.
   - **Example**:
     ```java
     String query = "SELECT * FROM users WHERE username = '" + username + "' AND password = '" + password + "'";
     Statement stmt = connection.createStatement();
     ResultSet rs = stmt.executeQuery(query);
     ```

   **Zest Script**:
   ```json
   {
     "zest": {
       "version": "0.4",
       "about": "Classic SQL Injection Test",
       "actions": [
         {
           "url": "http://example.com/login",
           "method": "POST",
           "data": "username=test' OR '1'='1&password=test",
           "elementType": "ZestRequest"
         },
         {
           "regex": "error|exception",
           "location": "RESPONSE_BODY",
           "elementType": "ZestConditionRegex"
         },
         {
           "message": "Potential SQL Injection detected",
           "elementType": "ZestActionFail"
         }
       ]
     }
   }
   ```

2. **SQL Injection via ORM (e.g., Hibernate)**
   - **Scenario**: Building dynamic queries using native SQL in ORM frameworks.
   - **Example**:
     ```java
     Query query = session.createQuery("FROM User WHERE username = '" + username + "'");
     List users = query.getResultList();
     ```

   **Zest Script**:
   ```json
   {
     "zest": {
       "version": "0.4",
       "about": "ORM-based SQL Injection Test",
       "actions": [
         {
           "url": "http://example.com/userSearch",
           "method": "GET",
           "data": "username=test' OR '1'='1",
           "elementType": "ZestRequest"
         },
         {
           "regex": "error|exception",
           "location": "RESPONSE_BODY",
           "elementType": "ZestConditionRegex"
         },
         {
           "message": "Potential ORM SQL Injection detected",
           "elementType": "ZestActionFail"
         }
       ]
     }
   }
   ```

3. **Blind SQL Injection**
   - **Scenario**: Exploiting SQL injection vulnerabilities where no direct feedback is given to the attacker (boolean-based, time-based).
   - **Example (Time-Based)**:
     ```java
     String query = "SELECT * FROM users WHERE username = '" + username + "'";
     ```

   **Zest Script**:
   ```json
   {
     "zest": {
       "version": "0.4",
       "about": "Time-based Blind SQL Injection Test",
       "actions": [
         {
           "url": "http://example.com/login",
           "method": "POST",
           "data": "username=test' OR '1'='1'--&password=test",
           "elementType": "ZestRequest"
         },
         {
           "delay": 10,
           "elementType": "ZestActionSleep"
         },
         {
           "url": "http://example.com/login",
           "method": "POST",
           "data": "username=test' OR SLEEP(10)--&password=test",
           "elementType": "ZestRequest"
         },
         {
           "lessThan": 9,
           "elementType": "ZestConditionTimeElapsed"
         },
         {
           "message": "Potential Time-based Blind SQL Injection detected",
           "elementType": "ZestActionFail"
         }
       ]
     }
   }
   ```

4. **SQL Injection in Stored Procedures**
   - **Scenario**: Insecure dynamic SQL in stored procedures.
   - **Example**:
     ```java
     String query = "{call getUserByName('" + username + "')}";
     CallableStatement stmt = connection.prepareCall(query);
     ResultSet rs = stmt.executeQuery();
     ```

   **Zest Script**:
   ```json
   {
     "zest": {
       "version": "0.4",
       "about": "Stored Procedure SQL Injection Test",
       "actions": [
         {
           "url": "http://example.com/userProfile",
           "method": "POST",
           "data": "username=test'); EXEC xp_cmdshell('dir');--",
           "elementType": "ZestRequest"
         },
         {
           "regex": "error|exception",
           "location": "RESPONSE_BODY",
           "elementType": "ZestConditionRegex"
         },
         {
           "message": "Potential Stored Procedure SQL Injection detected",
           "elementType": "ZestActionFail"
         }
       ]
     }
   }
   ```

These scripts can help DAST tools like OWASP ZAP accurately detect various types of SQL injection vulnerabilities in Java applications, minimizing false positives and negatives.

---

**References:**
- Secure coding practices for defending against SQL injection attacks【4:5†source】.
- Various SQL injection vectors and advanced techniques to enhance detection coverage  .
- The foundation and capabilities of Zest scripting for vulnerability detection【17†Zest_Scripting_Documentation.md】.